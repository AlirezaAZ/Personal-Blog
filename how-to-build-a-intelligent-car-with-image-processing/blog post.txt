[https://virgool.io/@hadiakhojasteh/how-to-build-a-intelligent-car-with-image-processing-]

چطوری خودرومونو با کمک پردازش تصویر هوشمند کنیم؟

در حال حاضر بیش از 20 میلیون خودرو در جاده های ایران وجود داره و این تعداد در جهان بیش از یک میلیارد هست. آماری که باعث میشه امنیت یکپارچه، بخشی جداناپذیر از وسایل نقلیه بسیاری از تولیدکنندگان خودرو باشه و بسیاری از قوانین و استانداردهای جهانی برای امنیت وسایل نقلیه وجود داشته باشه. با این حال هک خودرو عمری به اندازه 15 سال داره؛ تغییر مدیریت موتور و تزریق سوخت، ارسال سیگنال های مخفی برای واحدهای کنترل الکترونیکی (Electronic Control Units یا ECUs) خودرو یا ارسال ترافیک جعلی برای سیستم مسیریابی آنلاین و تغییر مسیر خودرو در این سال ها اتفاق افتاده. جالبه بدونید به صورت غیر رسمی گروه هایی ادعای دسترسی غیرمجاز به سیستم ایمنی خودروها یا ارتباط از راه دور با خودروهای متصل رو داشتند.
از طرف دیگه، در سال های اخیر هوش مصنوعی با ورود به دنیای وسایل نقلیه، نمونه های موفقی از خودروهای خودران هوشمند رو به دنیا معرفی کرده. با مستقر شدن تعداد کافی از این خودروهای خودران، جان میلیون ها انسان از خطر مرگ حفظ میشه و به شکل چشم گیری سرعت گذر جهان به انرژی های پاک بیشتر خواهد شد.

خودروی خودران شرکت Waymo (زیر مجموعه هلدینگ آلفابت) با بهره گیری از تجارب خودرو خودران گوگل در ساخت

در این پست قصد داریم با رویکرد آموزشی و مرحله به مرحله، سیستمی طراحی کنیم که پس از دریافت تصاویر دوربین تعبیه شده در جلوی خودرو و پردازش این تصاویر، تغییر مسیر ناگهانی راننده بر اثر خستگی یا خطای انسانی رو تشخیص داده و از طریق علائم داخل خودرو به راننده اخطار بده.
برای پیاده سازی این سیستم از یک دوربین و ارسال تصاویر دریافتی به لپ تاپ از یک طرف، و ارسال فرمان های کنترلی عوامل هشداردهنده به سامانه مالتی پلکس خودرو از طرف دیگه استفاده کرده ایم؛ یعنی تصاویر به صورت بلادرنگ (Real-time) پردازش شده و در صورت تغییر مسیر ناگهانی، فرمان هشدار داده میشه. از اونجاییکه برای دسترسی به سیستم شبکه خودرو نیازمند کمی قهرمان بازی هستیم، توصیه میشه اگر دنبال دردسر نیستید این کار رو روی خودرو خودتون امتحان نکنید😉. 
در این ماجراجویی، خودرو "رانا" رو انتخاب کردیم. خودرویی که بر پایه پلتفرم 206 صندوق دار و با کمی تغییر در ظاهر و چراغ های جلو و عقب ساخته شده. البته با نگاهی فنی تر به این خودرو، متوجه میشید که از تمامی تولیدات خودروساز، وسیله و قطعه ای در این خودرو وجود داره. 

*****اینجا تصویر رانای مورد نظر رو میذارم :)*****
زیر نویس: خودروی مورد آزمایش ما؛ هدف ایجاد یک سیستم هشدار برای مواقعی هست که خودرو از مسیر اصلی یا از باند جاده ای که در حال حرکت هست خارج بشه. 

در بخش اول سعی میکنیم تصاویر گرفته شده از جلوی خودرو رو پردازش کرده و مسیر حرکت اصلی خودرو رو تشخیص بدیم و در بخش دوم با هک خودرو و متصل شدن به شبکه الکترونیکی داخل خودرو، فرمان های کنترلی لازم برای هشدار به راننده رو ارسال میکنیم.
پردازش تصاویر دریافتی
زمانیکه ما رانندگی می کنیم، با کمک چشمامون خطوط جاده رو به عنوان یک مرجع ثابت برای تصمیم گیری ها و هدایت خودرو در نظر می گیریم. این اولین چیزیه که در طراحی خودروهای خودران توسط الگوریتم های مختلف پیاده سازی می شه. در اینجا ما تصویری مشابه تصویر سمت راست رو دریافت کرده و با الگوریتم های پردازش تصویر، مسیر (لاین) ی که در حال حرکت در اون هستیم - مشابه تصویر سمت چپ - رو مشخص میکنیم. در این پست از ویدیو هایی که در هنگام رانندگی از جاده ها در روز و شب از داخل ماشین ضبط کردیم، استفاده میکنیم. این تصاویر به علت سرعت بالای خودرو، مناسب نبودن مکان دوربین و نور و محیط واقعی دارای نویز بسیار بالایی هستند.

نمونه خروجی سیستم برای تصاویر واقعی گرفته شده از رانندگی در روز و شب؛ سمت راست تصاویر ورودی و سمت چپ تصاویر پردازش شده برای تشخیص لاین فعلی در حال رانندگی 

طیف خاکستری و حذف نویز
در این پست برای پردازش تصاویر از OpenCV فریم ورک بینایی کامپیوتر - پردازش تصویر و زبان ++C استفاده خواهیم کرد. در اولین گام بخش بالا و پایین تصاویر که اطلاعات مهمی از جاده رو شامل نمیشند، حذف میکنیم. چون بیشتر الگوریتم ها از تفاوت تغییر رنگ (یا همان نور یا تاثیر گذاری یک شی در بخشی از تصویر و در اینجا خط کشی جاده) استفاده می کنند، در همین مرحله تصویر رو به طیف خاکستری تبدیل می کنیم؛ یعنی مقدار هر پیکسل در سه کانال رنگی تصویر (قرمز، سبز و آبی یا RGB) ورودی رو به یک مقدار بین 0 تا 255 تبدیل میکنیم.
     Mat3b img = imread(argv[1]);     //Load image 
     Rect roi(0, 420, img.cols, img.rows - 500);     //Setup a rectangle to define region of interest
     Mat3b img_crop = img(roi);     //Crop the full image to rectangle ROI 
     Mat img_gray;
     cvtColor(img_crop, img_gray, CV_BGR2GRAY);     // Convert image to gray
     // Show results
     imshow("Original", img);
     imshow("Crop", img_crop);
     imshow("Gray", img_gray);

تبدیل تصویر رنگی ورودی دریافت شده از دوربین به تصویر طیف خاکستری و حذف بالا و پایین در تصویر روز (راست) و شب (چپ)
یافتن خطوط خط کشی و جداسازی
قبل از تشخیص لبه ها، به روشنی باید چیزی که در تصویر به دنبال اون هستیم رو مشخص کنیم. خط کشی جاده ها همیشه سفید یا زرد هستند. با نگاه بیشتر به تصاویر گرفته شده، یک روش ساده برای جداسازی خطوط خط کشی سفید، استخراج پیکسل هایی ای که مقدار بیشتری نسبت به بقیه پیکسل های مجاور یا درون تصویر دارند. بنابراین نقاطی رو انتخاب می کنیم که مقداری کمی بیشتر از چارک بالای مقدار همه پیکسل های تصویر دارند.
در ادامه چون رنگ زرد به آسانی قابل جداسازی در یک تصویر سه کاناله RGB نیست و ممکنه این مقادیر در حالت برداشت مقدار بر حسب چارک از بین برند، فرمت نمایش تصویر رو به Hue, Saturation, Value یا HSV تبدبل میکنیم و نقاط نظیر با رنگ های زرد تصویر HSV رو در تصویر طیف خاکستری به عنوان نقاط مورد نظر استخراج می کنیم (برای یافتن طیف های رنگی می تونید از فتوشاپ یا این ابزار آنلاین استفاده کنید). نهایتا مجموع نقاط انتخاب شده سفید و زرد با اعمال یک فیلتر حذف نویز با میانگین گیری از پیکسل های همسایه، برای تحلیل های بعدی استفاده می شند.
     Mat mask_hsv_yellow, mask_white, img_mask;
     // Make target image by apply yellow and white mask
     Scalar m = mean(img_gray);
     cvtColor(img, mask_hsv_yellow, CV_BGR2HSV);
     inRange(img_crop, Scalar(20, 85, 85), Scalar(30, 255, 255), mask_hsv_yellow);
     inRange(img_gray, Scalar(m[0] + (255 - m[0]) / 3.5), Scalar(255), mask_white);
     bitwise_or(mask_white, mask_hsv_yellow, img_mask);
     GaussianBlur(img_mask, img_mask, cv::Size(5, 5), 0);
     imshow("Mask", img_mask);

استخراج پیکسل های مورد نیاز برای شناسایی خط کشی های جاده در تصاویر روز (راست) و شب (چپ)
تشخیص لبه های خطوط
خُب، بعد از حذف مقادیری غیر از خطوط از تصویر، باید لبه های اصلی خط کشی ها رو تشخیص بدیم. برای اینکار ابتدا باید به این سوال پاسخ بدیم:
از نظر ریاضی در یک تصویر (یک ماتریس از مقادیر داده رنگی)، چه چیزی لبه رو تعریف می کنه؟
با نگاهی دقیق تر به داده های اطراف یک لبه، می تونیم به این نتیجه برسیم که لبه ها بخش هایی هستند که مقادیر پیکسل ها به سرعت تغییر می کنند. بنابراین تشخیص لبه، یافتن پیکسل هایی ای که در مقایسه با همسایه هاشون مقادیری به شدت متفاوت دارند.

نمونه تشخیص خط کشی با استفاده از گرادیان تغییر مقادیر پیکسل ها برای یک لبه
خوشبختانه در حوزه پردازش تصویر، این مسئله قبلا حل شده است. الگوریتم آشکارساز لبه Canny به همین روش و با یافتن مقادیر گرادیان در یک آستانه مشخص در طول تصویر اینکار رو انجام میده. بنابراین نیازی نیست که به مقادیر رنگ تصاویر فکر کنیم، تنها تغییرات مقدار برای ما اهمیت داره و می تونیم با این الگوریتم لبه رو در تصاویر مرحله قبل پیدا کنیم.
     Mat detected_edges, img_mask;
     int const max_lowThreshold = 255;
     int lowThreshold = 210, ratio = 3, kernel_size = 3;
     char* window_name = "Edge Map";
     // CannyThreshold: Trackbar callback - Canny thresholds input with a ratio 1:3
     void CannyThreshold(int, void*){
     blur(img_mask, detected_edges, Size(3, 3));     // Reduce noise with a kernel 3x3
     Canny(detected_edges, detected_edges, lowThreshold, lowThreshold * ratio, kernel_size);     // Canny detector
     imshow(window_name, detected_edges);     // Using Canny's output as a mask, and display our result
}

detected_edges.create(img_mask.size(), img_mask.type());     // Create a window
namedWindow(window_name);
createTrackbar("Min Threshold:", window_name, &lowThreshold, max_lowThreshold, CannyThreshold);     // Create a Trackbar for user to enter threshold
CannyThreshold(0, 0);     // Show the image

نمونه خروجی برای الگوریتم آشکارساز لبه برای خط کشی های جاده در تصاویر روز (راست) و شب (چپ)
تشخیص خطوط مسیر
تا به اینجای کار، پیکسل هایی که لبه های خطوط رو مشخص می کنند، انتخاب کردیم. حالا باید با اتصال این پیکسل ها به هم خطوط مشخص کننده مسیر رو تشخیص بدیم. مثل مرحله قبل این مسئله هم با یک تئوری ریاضی قابل حل هست. بیایید دوباره نگاهی به لبه های یافته شده بیاندازیم:

لبه یافته شده در یک ناحیه مشخص شده (سبز)؛ خطوط کاندید برای لبه با رنگ آبی در تصویر مشخص شده است.

با نگاه نزدیک به لبه ها، مشخصه که بهترین خطی که یک لبه رو نمایش میده، خطی ای که بیشترین تعداد پیکسل از لبه رو هم شامل میشه (خط ب در تصویر بالا). یافتن این خط یک مسئله دشوار هست. چرا که ممکنه تعداد این خطوط خیلی زیاد باشه و نیاز هست تا تمام خط های ممکن بررسی بشند.
برای این منظور می تونیم از تبدیل هاف استفاده کنیم. در این تبدیل، ما تمام پیکسل های لبه رو به یک فرم نمایش ریاضی دیگه تبدیل میکنیم. بعد از تبدیل کامل، هر پیکسل در "فضای تصویر" به یک خط یا منحنی در "فضای هاف" تبدیل می شه؛ یعنی در فضای هاف هر خط به شکل یک نقطه در تصویر نمایش داده میشه. 

نمایشی از فضای تصویر و فضای هاف متناظر به همراه پارامترها (منبع)
بنابراین ما نیازی به حل مسئله یافتن خطی که از همه پیکسل های همسایه عبور کنه نداریم و تنها کافی است خطی رو پیدا کنیم که در فضای هاف هست و نهایتا این خط رو به فضای تصویر نگاشت کنیم.
     Mat img_hlines = img_crop.clone();
     // Standard Hough Line Transform
     vector<Vec4i> lines;     // will hold the results of the detection
     HoughLinesP(detected_edges, lines, 1, CV_PI / 180, 50, 30, 10);     // runs the actual detection
     // Draw the lines
     for (size_t i = 0; i < lines.size(); i++) {
          Vec4i l = lines[i];
          line(img_hlines, Point(l[0], l[1]), Point(l[2], l[3]), Scalar(0, 255, 255), 2, CV_AA);
     }

خطوط یافت شده (زرد) با استفاده از پیکسل های لبه بعد از نگاشت از فضای هاف به فضای تصویر و قرار گرفته بر روی تصاویر اصلی
گروه بندی و تصمیم گیری
در مرحله آخر پردازش تصاویر، هدف ایجاد یک معیار برای تصمیم گیری است. اگر تا اینجا همه چیز درست پیاده سازی شده باشه، خطوطی خواهیم داشت که نماینده ای از خط کشی جاده برای مسیری هستند که در حال عبور از اون هستیم. ابتدا این خطوط رو به دو دسته خط کشی سمت راست و چپ تقسیم می کنیم. یک تفاوت آشکار بین دو گروه از خط ها، جهت شیب این خطوط است. اندازه شیب هر خط زاویه اون رو اندازه می گیره. خطوط افقی شیب صفر و خطوط عمودی شیب بینهایت دارند. پس خط های یافته شده اندازه ای بین این دو مقدار دارند، چراکه اون ها از پایین تصویر به سمت مرکز، نسبت به افق زاویه دارند.
جهت شیب یک خط نشون میده که با حرکت از چپ به راست، آیا خط به بالا حرکت می کنه یا پایین؟ خطوط با شیب منفی به سمت پایین و خطوط با شیب مثبت به بالا حرکت می کنند. این همان چیزی است که در سیستم مختصات عادی اتفاق می افته. در سیستم مختصاتی که ما از اون استفاده می کنیم، نقطه مرکز در گوشه بالا سمت چپ تصویر هست؛ یعنی در اینجا جهت شیب ما معکوس خواهد بود.
پس خط های سمت راست شیب مثبت دارند و به پایین حرکت می کنند. مشاهدات نشون میدند که خطوطی که شیب خیلی کمی دارند احتمالا خطوط خوبی برای یافتن خط تصمیم گیر نیستند. بنابراین سعی می کنیم از این بین خطوطی که شیبی بیشتر/کمتر از 0.4 (+/-) دارند رو انتخاب کنیم. 
bool less_left(const Vec4i& lhs, const Vec4i& rhs){     return lhs[0] < rhs[0];     }
bool less_right(const Vec4i& lhs, const Vec4i& rhs) {     return lhs[0] > rhs[0];     }
vector<Vec4i> rightls, leftls;
// Calculating the slope and group lines
float slope = (float)(l[3] - l[1]) / (l[2] - l[0]);
if (slope > 0.40) {     rightls.push_back(l);     }else if (slope < -0.40) {     leftls.push_back(l);     }
// Find regions
Point left_b, left_t, right_b, right_t;
if (leftls.size() > 0) {
     auto lmmx = minmax_element(leftls.begin(), leftls.end(), less_left);
     left_b = Point(get<0>(lmmx)[0][0], get<0>(lmmx)[0][1]);
     left_t = Point(get<0>(lmmx)[0][2], get<0>(lmmx)[0][3]);
}
if (rightls.size() > 0) {
     auto rmmx = minmax_element(rightls.begin(), rightls.end(), less_right);
     right_t = Point(get<0>(rmmx)[0][0], get<0>(rmmx)[0][1]);
     right_b = Point(get<0>(rmmx)[0][2], get<0>(rmmx)[0][3]);
}

Mat poly = img_hlines.clone();
vector<Point> vertices{ left_b, left_t, right_t, right_b };
vector<vector<Point>> pts{ vertices };
fillPoly(poly, pts, Scalar(58, 190, 37, 0));
addWeighted(poly, 0.50, img_hlines, 0.50, 0, img_hlines);

// Find reference line points by average top and bottom middle
float rx = (((right_b.x - left_b.x) / 2 + left_b.x) + ((right_t.x - left_t.x) / 2 + left_t.x)) / 2, ry = img_hlines.rows;
// Draw dashed reference line
Point p1(rx, 0), p2(rx, ry);
LineIterator itl(img_hlines, p1, p2, 8);
for (int i = 0; i < itl.count; i++, itl++) {
     if (i % 5 != 0) {     (*itl)[1] = 80;     (*itl)[2] = 75;     }
}

نتیجه نهایی پردازش تصویر برای تشخیص خطوط و یافتن خط تصمیم گیری میزان انحراف خودرو از جاده در شب (بالا) و روز (پایین)

خط تصمیم گیری که نماینده ای از انحراف خودرو از مسیر در حال حرکت هست، میانگینی از دو گروه است. برای این خط، مقدار میانگین بیشترین و کمترین x از هر گروه، مشخص کننده مقدار x خواهد بود.
آخرین مرحله در اینجا دریافت تصاویر از دوربین است که برای اینکار از کدهای زیر استفاده می کنیم. اگر علاقمندید که این تصاویر رو از طریق شبکه بین موبایل و لپ تاپ دریافت کنید، این کدها رو بررسی کنید.
     VideoCapture cap(0);     // open the default camera
     if(!cap.isOpened())     // check if we successfully connected to camera
          return -1;
     for(;;) {
          Mat frame;
          cap >> frame;     // get a new frame from camera
          // Our codes ...
          if(waitKey(30) >= 0) break;
     }
ما موفق شدیم! الان سیستمی داریم که می تونه مسیر خودرو رو تشخیص بده. کافیه با توجه به محل قرار گیری دوربین در جلو خودرو، در صورتیکه انحراف این خط بیشتر از میزان کالیبره شده بود؛ یعنی خودرو به صورت ناگهانی تغییر مسیر داد، فرمان های هشدار به راننده داده بشه.
اما منظور از فرمان هشدار چیه؟ در ادامه ماجراجویی می خوایم به همین سوال پاسخ بدیم.