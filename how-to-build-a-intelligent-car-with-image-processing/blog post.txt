[https://virgool.io/@hadiakhojasteh/how-to-build-a-intelligent-car-with-image-processing-]

چطوری خودرومونو با کمک پردازش تصویر هوشمند کنیم؟

در حال حاضر بیش از 20 میلیون خودرو در جاده های ایران وجود داره و این تعداد در جهان بیش از یک میلیارد هست. آماری که باعث میشه امنیت یکپارچه، بخشی جداناپذیر از وسایل نقلیه بسیاری از تولیدکنندگان خودرو باشه و بسیاری از قوانین و استانداردهای جهانی برای امنیت وسایل نقلیه وجود داشته باشه. مثلا در یکی از استانداردها ، کیفیت و حالت های کلید دسترسی به سیستم ضد سرقت یا ایموبیلایزر (Immobiliser) به گونه ای تعریف شده که باید در گیرنده، فرستنده و دیگر واحدهای کنترل حالت های مختلف زیادی داشته باشه تا در زمان کوتاهی قابل حدس نباشه.
هک خودرو عمری به اندازه 15 سال داره؛ تغییر مدیریت موتور و تزریق سوخت، ارسال سیگنال های مخفی برای واحدهای کنترل الکترونیکی (Electronic Control Units یا ECUs) خودرو یا ارسال ترافیک جعلی برای سیستم مسیریابی آنلاین و تغییر مسیر خودرو در این سال ها اتفاق افتاده. جالبه بدونید به صورت غیر رسمی گروه هایی ادعای دسترسی غیرمجاز به سیستم ایمنی خودروها یا ارتباط از راه دور با خودروهای متصل رو داشتند.
از طرف دیگه، در سال های اخیر هوش مصنوعی با ورود به دنیای وسایل نقلیه، نمونه های موفقی از خودروهای خودران هوشمند رو به دنیا معرفی کرده. با مستقر شدن تعداد کافی از این خودروهای خودران، جان میلیون ها انسان از خطر مرگ حفظ میشه و به شکل چشم گیری سرعت گذر جهان به انرژی های پاک بیشتر خواهد شد.

خودروی خودران شرکت Waymo (زیر مجموعه هلدینگ آلفابت) با بهره گیری از تجارب خودرو خودران گوگل در ساخت

در این پست قصد داریم با رویکرد آموزشی و مرحله به مرحله، سیستمی طراحی کنیم که پس از دریافت تصاویر دوربین تعبیه شده در جلوی خودرو و پردازش این تصاویر، تغییر مسیر ناگهانی راننده بر اثر خستگی یا خطای انسانی رو تشخیص داده و از طریق علائم داخل خودرو به راننده اخطار بده.
برای پیاده سازی این سیستم از یک دوربین معمولی تلفن همراه و ارسال تصاویر دریافتی به لپ تاپ از یک طرف، و ارسال فرمان های کنترلی عوامل هشداردهنده به سامانه مالتی پلکس خودرو از طرف دیگه استفاده کرده ایم؛ یعنی تصاویر به صورت بلادرنگ (Real-time) پردازش شده و در صورت تغییر مسیر ناگهانی، فرمان هشدار داده میشه. از اونجاییکه برای دسترسی به سیستم شبکه خودرو نیازمند کمی قهرمان بازی هستیم، توصیه میشه اگر دنبال دردسر نیستید این کار رو روی خودرو خودتون امتحان نکنید😉. 
در این ماجراجویی، خودرو "رانا" رو انتخاب کردیم. خودرویی که بر پایه پلتفرم 206 صندوق دار و با کمی تغییر در ظاهر و چراغ های جلو و عقب ساخته شده. البته با نگاهی فنی تر به این خودرو، متوجه میشید که از تمامی تولیدات خودروساز، وسیله و قطعه ای در این خودرو وجود داره. همانطور که گفته شد هدف ایجاد یک سیستم هشدار برای مواقعی هست که خودرو از مسیر اصلی یا از باند جاده ای که در حال حرکت هست خارج بشه. 
*****اینجا تصویر رانای مورد نظر رو میذارم :)*****
در بخش اول سعی میکنیم تصاویر گرفته شده از جلوی خودرو رو پردازش کرده و مسیر حرکت اصلی خودرو رو تشخیص بدیم و در بخش دوم با هک خودرو و متصل شدن به شبکه الکترونیکی داخل خودرو، فرمان های کنترلی لازم برای هشدار به راننده رو ارسال میکنیم.
پردازش تصاویر دریافتی
زمانیکه ما رانندگی می کنیم، با کمک چشمامون خطوط جاده رو به عنوان یک مرجع ثابت برای تصمیم گیری ها و هدایت خودرو در نظر می گیریم. این اولین چیزیه که در طراحی خودروهای خودران توسط الگوریتم های مختلف پیاده سازی می شه. در اینجا ما تصویری مشابه تصویر سمت راست رو دریافت کرده و با الگوریتم های پردازش تصویر، مسیر (لاین) ی که در حال حرکت در اون هستیم - مشابه تصویر سمت چپ - رو مشخص میکنیم. در این پست از ویدیو هایی که در هنگام رانندگی از جاده ها در روز و شب از داخل ماشین ضبط شده اند، استفاده میکنیم. این تصاویر به علت سرعت بالای خودرو، مناسب نبودن مکان دوربین و نور و محیط واقعی دارای نویز بسیار بالایی هستند.

نمونه خروجی سیستم برای تصاویر واقعی گرفته شده از رانندگی در روز و شب؛ سمت راست تصاویر ورودی و سمت چپ تصاویر پردازش شده برای تشخیص لاین فعلی در حال رانندگی 

طیف خاکستری و حذف نویز
در این پست برای پردازش تصاویر از OpenCV فریم ورک بینایی کامپیوتر و پردازش تصویر و زبان ++C استفاده خواهیم کرد. در اولین گام بخش بالا و پایین تصاویر که اطلاعات مهمی از جاده رو شامل نمیشند، حذف میکنیم. چون بیشتر الگوریتم ها از تفاوت تغییر رنگ (یا همان نور یا تاثیر گذاری یک شی در بخشی از تصویر و در اینجا خط کشی جاده) استفاده می کنند، در همین مرحله تصویر رو به طیف خاکستری تبدیل می کنیم؛ یعنی مقدار هر پیکسل در سه کانال رنگی تصویر (قرمز، سبز و آبی یا RGB) ورودی رو به یک مقدار بین 0 تا 255 تبدیل میکنیم.
     Mat3b img = imread(argv[1]);     //Load image 
     Rect roi(0, 420, img.cols, img.rows - 500);     //Setup a rectangle to define region of interest
     Mat3b img_crop = img(roi);     //Crop the full image to rectangle ROI 
     Mat img_gray;
     cvtColor(img_crop, img_gray, CV_BGR2GRAY);     // Convert image to gray
     // Show results
     imshow("Original", img);
     imshow("Crop", img_crop);
     imshow("Gray", img_gray);

تبدیل تصویر رنگی ورودی دریافت شده از دوربین به تصویر طیف خاکستری و حذف بالا و پایین در تصویر روز (راست) و شب (چپ)
یافتن خطوط خط کشی و جداسازی
قبل از تشخیص لبه ها، به روشنی باید چیزی که در تصویر به دنبال اون هستیم رو مشخص کنیم. خط کشی جاده ها همیشه سفید یا زرد هستند. با نگاه بیشتر به تصاویر گرفته شده، یک روش ساده برای جداسازی خطوط خط کشی سفید، استخراج پیکسل هایی ای که مقدار بیشتری نسبت به بقیه پیکسل های مجاور یا درون تصویر دارند. بنابراین نقاطی رو انتخاب می کنیم که مقداری کمی بیشتر از چارک بالای مقدار همه پیکسل های تصویر دارند.
در ادامه چون رنگ زرد به آسانی قابل جداسازی در یک تصویر سه کاناله RGB نیست و ممکنه این مقادیر در حالت برداشت مقدار بر حسب چارک از بین بروند، فرمت نمایش تصویر رو به Hue, Saturation, Value یا HSV تبدبل میکنیم و نقاط نظیر با رنگ های زرد تصویر HSV رو در تصویر طیف خاکستری به عنوان نقاط مورد نظر استخراج می کنیم (برای یافتن طیف های رنگی می تونید از فتوشاپ یا این ابزار آنلاین استفاده کنید). نهایتا مجموع نقاط انتخاب شده سفید و زرد با اعمال یک فیلتر حذف نویز با میانگین گیری از پیکسل های همسایه، برای تحلیل های بعدی استفاده می شند.
     Mat mask_hsv_yellow, mask_white, img_mask;
     // Make target image by apply yellow and white mask
     Scalar m = mean(img_gray);
     cvtColor(img, mask_hsv_yellow, CV_BGR2HSV);
     inRange(img_crop, Scalar(20, 85, 85), Scalar(30, 255, 255), mask_hsv_yellow);
     inRange(img_gray, Scalar(m[0] + (255 - m[0]) / 3.5), Scalar(255), mask_white);
     bitwise_or(mask_white, mask_hsv_yellow, img_mask);
     GaussianBlur(img_mask, img_mask, cv::Size(5, 5), 0);
     imshow("Mask", img_mask);

استخراج پیکسل های مورد نیاز برای شناسایی خط کشی های جاده در تصاویر روز (راست) و شب (چپ)
تشخیص لبه های خطوط
خُب، بعد از حذف مقادیری غیر از خطوط از تصویر، باید لبه های اصلی رو تشخیص بدیم و سعی کنیم مسیر اصلی رو تشخیص بدیم. برای اینکار ابتدا باید به این سوال پاسخ بدیم:
با نگاه ریاضی به تصویر (یک ماتریس از مقادیر داده رنگی)، چه چیزی یک لبه رو تعریف می کند؟
با نگاهی دقیق تر به داده های اطراف یک لبه، می تونیم به این نتیجه برسیم که لبه ها بخش هایی هستند که مقادیر پیکسل ها به سرعت تغییر می کنند. بنابراین تشخیص لبه با نگاه ریاضی، یافتن پیکسل هایی ای که در مقایسه با همسایه هاشون مقادیری به شدت متفاوت دارند.

نمونه تشخیص خط کشی با استفاده از گرادیان تغییر مقادیر پیکسل ها برای یک لبه
خوشبختانه در حوزه پردازش تصویر، این مسئله قبلا حل شده است. الگوریتم آشکارساز لبه Canny به همین روش و با یافتن مقادیر گرادیان در یک آستانه مشخص در طول تصویر اینکار رو انجام میده. برای اطلاعات بیشتر در مورد این الگوریتم می تویند به ویکیپدیا مراجعه کنید. بنابراین نیازی نیست که به مقادیر رنگ تصاویر فکر کنیم، تنها تغییرات مقدار برای ما اهمیت داره و می تونیم با این الگوریتم لبه رو در تصاویر مرحله قبل اعمال کنیم.
     Mat detected_edges, img_mask;
     int const max_lowThreshold = 255;
     int lowThreshold = 210, ratio = 3, kernel_size = 3;
     char* window_name = "Edge Map";
     // CannyThreshold: Trackbar callback - Canny thresholds input with a ratio 1:3
     void CannyThreshold(int, void*){
     blur(img_mask, detected_edges, Size(3, 3));     // Reduce noise with a kernel 3x3
     Canny(detected_edges, detected_edges, lowThreshold, lowThreshold * ratio, kernel_size);     // Canny detector
     imshow(window_name, detected_edges);     // Using Canny's output as a mask, and display our result
}

detected_edges.create(img_mask.size(), img_mask.type());     // Create a window
namedWindow(window_name);
createTrackbar("Min Threshold:", window_name, &lowThreshold, max_lowThreshold, CannyThreshold);     // Create a Trackbar for user to enter threshold
CannyThreshold(0, 0);     // Show the image

نمونه خروجی برای الگوریتم آشکارساز لبه برای خط کشی های جاده در تصاویر روز (راست) و شب (چپ)
 تشخیص لبه های خطوط
تا به اینجای کار، پیکسل هایی که لبه های خطوط رو مشخص می کنند، انتخاب کردیم. حالا باید با اتصال این پیکسل ها به هم خطوط مشخص کننده مسیر رو ایجاد کنیم. مثل مرحله قبل این مسئله هم با یک تئوری ریاضی قابل حل هست. بیایید برای حل این مسئله دوباره نگاهی به لبه های یافته شده بیاندازیم:

لبه یافته شده در یک ناحیه مشخص شده (سبز)؛ خطوط کاندید برای لبه با رنگ آبی در تصویر مشخص شده است.

با نگاه نزدیک به لبه ها، مشخصه که بهترین خطی که یک لبه رو نمایش میده، خطی ای که بیشترین تعداد پیکسل از لبه رو هم شامل میشه. یافتن این خط یک مسئله دشوار هست. چراکه ممکنه تعداد این خطوط خیلی زیاد باشه و نیاز هست تا تمام خط های ممکن بررسی بشند.
برای این منظور می توان از تبدیل هاف استفاده کرد. در این تبدیل، ما تمام پیکسل های لبه رو به یک فرم نمایش ریاضی دیگه تبدیل میکنیم. بعد از تبدیل کامل، هر پیکسل در "فضای تصویر" به یک خط یا منحنی در "فضای هاف" تبدیل می شه؛ یعنی در فضای هاف هر خط به شکل یک نقطه نمایش داده میشه. 

نمایشی از فضای تصویر و فضای هاف متناظر به همراه پارامترها (منبع)
بنابراین ما نیازی به حل مسئله یافتن خطی که از همه پیکسل های همسایه عبور کنه نداریم و تنها کافی است خطی رو پیدا کنیم که در فضای هاف تقاطع داره و نهایتا این خط رو به فضای تصویر نگاشت کنیم.
     Mat img_hlines = img_crop.clone();
     // Standard Hough Line Transform
     vector<Vec4i> lines;     // will hold the results of the detection
     HoughLinesP(detected_edges, lines, 1, CV_PI / 180, 50, 30, 10);     // runs the actual detection
     // Draw the lines
     for (size_t i = 0; i < lines.size(); i++) {
          Vec4i l = lines[i];
          line(img_hlines, Point(l[0], l[1]), Point(l[2], l[3]), Scalar(0, 255, 255), 2, CV_AA);
     }
     imshow("detected lines", img_hlines);

خطوط یافت شده (زرد) با استفاده از پیکسل های لبه بعد از نگاشت از فضای هاف به فضای تصویر و قرار گرفته بر روی تصاویر اصلی
