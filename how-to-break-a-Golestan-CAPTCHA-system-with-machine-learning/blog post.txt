 همه‌ی ما از کپچا (CAPTCHA) فراری ایم - همون تصاویر مزاحمی رو میگم که نوشته های درهم ریخته است و برای اینکه به فرم یا صفحه ای از سایت دسترسی داشته باشیم باید اونو تایپ کنیم. کپچاها برای تشخیص انسان از بات ها (همون برنامه های اتوماتیک) و معمولا برای جلوگیری از ورود به بخشی خاص، جلوگیری از پر کردن فرم ها یا کاهش برخی حملات طراحی شدند. جالبه بدونید در حال حاضر مدتی است که کپچاهای متنی محبوبیت خودشون رو از دست دادند و جای خودشون رو به کپچاهای تصویری یا موارد مشابه دادند.

نمونه ای از کپچای گوگل جایگزین مناسبی برای کپچاهای متنی
سیستم گلستان رو تقریبا همه می شناسند. همون سیستم اتوماسیون معروف دانشگاه های ایران که پیدا کردن هر چیزی داخل اون نیازمند یک دوره دکتری تخصصی "زبانهای رسمی و روش های صوری" است!
توی این پست قصد داریم ساده و مرحله به مرحله شکستن کپچای متنی سیستم گلستان رو با بهره گیری از قدرت یادگیری ماشین/عمیق و داده های آماری بررسی کنیم. توصیه میشه اگر دنبال دردسر نیستید این کار رو توی خونه امتحان نکنید😉.
برای شروع ماجراجویی، ابتدا نگاهی به فرم ورود سیستم گلستان به همراه تصویر کپچای متنی می اندازیم:

صفحه ورود سیستم گلستان دانشگاه شهید بهشتی
خُب، هر الگوریتم یادگیری ماشین نیازمند داده های زیادی هست. شکستن کپچا هم از این قاعده مستثنی نیست. بنابراین برای اینکه بتونیم یک کپچای متنی رو بشکنیم، نیازمند تعداد زیادی تصویر هستیم. برای اینکار یک اسکریپت ساده Shell میتونه چاره ی کار باشه.
#! /bin/bash
# use this script for downloading Golestan Captcha
for ((i=0;i < 10000000;i++)){
    wget -x --no-check-certificate https://support.nowpardaz.ir/frm/captcha/captcha.ashx -O ./$i.png
}
exit 0
این اسکریپت سعی میکنه تعداد زیادی از فایل های تصویر رو دانلود کنه و با فرمت gif. ذخیره کنه (این فرمت فایل های خروجی کدی هست که کپچا رو در سیستم اصلی تولید میکنه). 

نمونه ای از تصاویر کپچاهای استخراج شده از سیستم گلستان
حالا سعی میکنیم تا تصاویر ورودی به سیستم رو حدالامکان به ساده ترین شکل ممکن تبدیل کنیم. بدین منظور سعی میکنیم تا نوشته پایین تصاویر رو حذف کنیم.
از اونجاییکه من یکی از طرفدارای پر و پا قرص زبان های سطح پایین هستم در این مطلب از زبان ++C و کتابخونه OpenCV استفاده خواهیم کرد.
    Mat3b img = imread(argv[1]);                        //Load image
    Rect roi(0, 0, img.cols, img.rows / 1.11);      //Setup a rectangle to define region of interest
    Mat3b crop = img(roi);                                   //Crop the full image to rectangle ROI
    imshow("Original", img);
    imshow("Crop", crop);
کد بالا بخش پایین تصویر ورودی رو حذف میکنه که به عنوان یک آرگومان دریافت شده. بنابراین تا اینجای کار داده های آموزشی برای سیستم یادگیری مون رو در اختیار داریم.

رویکرد کلی سیستم یادگیری برای شکستن کپچا
با داشتن داده های آموزشی کافی، رویکرد کلی بالا پاسخ درستی تولید می کنه؛ یعنی فقط کافیه تعداد خیلی زیادی تصویر رو به یک شبکه عصبی کانولوشن (Convolutional Neural Network) پیچیده که وظیفه پردازش تصویر رو داره بدیم و با یک شبکه عصبی دیگه که وظیفه ی پیش بینی در مورد کل تصویر رو داره مسئله رو حل کنیم. اما این رویکرد با کمی تغییرات پاسخ های بهتر با محاسبات کمتر رو تولید میکنه.
خوشبختانه کپچایی که ما قصد شکستن اون رو داریم از پنج حرف تشکیل میشه. بنابراین اگر بتونیم روشی برای جداکردن حروف در تصویر داشته باشیم، شبکه عصبی تنها نیاز داره تا یک حرف رو کلاس بندی (Classify) کنه. یک روش ساده شکستن تصویر افقی به پنج قسمت مساوی هست. اما اگر به نمونه های دریافت شده در تصویر دقت کنید، ممکنه به دلیل جمع شدن حروف در یک طرف، حروف به درستی قطعه بندی (Segmentation) نشن. بنابراین برای اینکه محل دقیق خطوط تقسیم بندی در تصویر رو پیدا کنیم، سعی میکنیم تا تجمع پیکسل های غیر سفید در تصویر رو پیدا کنیم (یا به صورت ساده تعداد پیکسل در هر خط عمودی رو بشماریم)، و از اونجاییکه بین حروف فاصله کمی وجود داره، تعداد پیکسل بیشتر با تقریب خوبی جای هر حرف در تصویر رو به ما نشون میده. بعد از اینکاریک الگوریتم خوشه بندی (Clustering) می تونه به طور موثر تصویر رو به پنج بخش مختلف تقسیم کنه.
ابتدا باید تصویر ورودی تبدیل به تصویر سیاه و سفید بشه و بخشی از نویز اون نیز حذف بشه تا مطمئن بشیم همه چیز به بهترین نحو ممکن انجام میشه. 
    //Convert image to gray, blur and sharpen it
    Mat img_gray, img_sharp;
    cvtColor(crop, img_gray, CV_BGR2GRAY);
    blur(img_gray, img_gray, Size(4, 4));
    GaussianBlur(img_gray, img_sharp, cv::Size(0, 0), 6);
    addWeighted(img_gray, 1.80, img_sharp, -0.55, 0, img_sharp);
کدهای بالا با پردازش تصویر، جادوی زیر رو انجام میده:

مراحل پردازش تصویر ورودی
برای قطعه بندی تصاویر؛ یعنی برش تصویر به کاراکترهای جداگانه، ساده ترین روش استفاده از نمودار هیستوگرام و یافتن دسته هایی از پیکسل هاست که در جای خاصی تجمع دارند.
    int histSize = 140;
    Mat histdata, img_sharp_not;
    bitwise_not(img_sharp, img_sharp_not);
    //Calculate the histograms for input image
    reduce(img_sharp_not, histdata, 0, CV_REDUCE_SUM, CV_32S);
    int hist_w = img.cols * 4; int hist_h = img.rows * 4;
    int bin_w = cvRound((double)hist_w / histSize);
    int txtMargin = 20;
    Mat histImage(hist_h + txtMargin, hist_w + txtMargin, CV_8UC3, Scalar(255, 255, 255));
    //Normalize the result to [ 0, histImage.rows ]
    normalize(histdata, histdata, 0, histImage.rows, NORM_MINMAX, -1, Mat());
    
    for (int i = 1; i < histSize; i++){    //Draw histogram in summary
        line(histImage, Point(bin_w*(i - 1) + txtMargin, hist_h - cvRound(histdata.at<int>(i - 1))), Point(bin_w*(i) + txtMargin, hist_h - cvRound(histdata.at<int>(i))), Scalar(255, 100, 0), 2, 8, 0);
     }

نمودار هیستوگرام تعداد پیکسل ها برای قطعه بندی تصویر به ازای کپچای ورودی بالا سمت راست نمودار
همون طور که در تصویر هم می بینید نقاطی که افت شدید مقدار داریم، دقیقا همون نقاطی هستند که باید تصویر برش داده بشه تا تصاویر کاراکترها استخراج بشند.
از اونجاییکه این روش با پیچیدگی هایی همراه هست، ما در اینجا با روش خوشه بندی k-means سعی میکنیم تا بهترین خطوط برای جداسازی توی تصویر بعد از فیلتر رو پیدا کنیم. توی این روش تصویر نهایی رو به شکل ماتریسی از صفر و یک ها (فقط نقاط سفید)، در نظر می گیریم (پیکسل هایی با مقدار بیشتر از یک آستانه را یک در نظر میگیریم). پنج نقطه اولیه تصادفی در ماتریس انتخاب میکنیم. با روش k-means سعی میکنیم نقاط درون تصویر رو به پنج خوشه (Cluster) تقسیم کنیم. نقطه مرکز هر خوشه، مرکز هر کاراکتر خواهد بود.

پردازش های بیشتری هم میشه روی تصویر انجام داد. مثلا برخی تصاویر که کنتراست کمتری دارند (رنگ روشن تری دارند)، قابلیت نرمال سازی و افزایش کنتراست رو دارند. تا همین میزان پردازش برای ایجاد ورودی های شبکه عصبی ما کافی هست (اگر دوست دارید شما می تونید تا میزان دلخواه پردازش روی تصویر انجام بدید.).



حالا نوبت شماست که دست به کار بشید و 